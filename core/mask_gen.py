import itertools


MASK_MAP = {
    "?u":   "ABCDEFGHIJKLMNOPQRSTUVWXYZ",       # Uppercase letters
    "?uv":  "ABCDEFGHIJKLMNOPQRSTUVWXYZÅÄÖÉ",   # Uppercase letters Swedish
    "?l":   "abcdefghijklmnopqrstuvwxyz",       # Lowercase letters
    "?lv":  "abcdefghijklmnopqrstuvwxyzåäöé",   # Lowercase letters Swedish
    "?d":   "0123456789",                       # Digits
    "?s":   "!@#$%^&*()-_=+[]{}|;:',.<>?/`~",   # Special characters
    "?p":   "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%^&*()-_=+[]{}|;:',.<>?/`~",     # standard printable character
    "?h":   "0123456789ABCDEF",                 # hexidecimal
    "?x":   " "                                 # Space character

}


def generate_mask_candidates(mask):
    # Ensure the parsed mask components include the "?" symbol
    char_sets = [MASK_MAP[f"?{m}"] for m in mask.split("?")[1:] if f"?{m}" in MASK_MAP]

    # Count generated candidates
    count = 0
    for combo in itertools.product(*char_sets):
        count += 1
        yield "".join(combo).encode()


def yield_maskbased_batches(generator, batch_size):
    batch = []
    total_batches = 0
    for candidate in generator:
        batch.append(candidate)
        if len(batch) >= batch_size:
            total_batches += 1
            yield batch
            batch = []
    if batch:
        total_batches += 1
        yield batch


def get_mask_count(mask):
    """
    Calculate the number of possible passwords generated by the mask.
    """
    char_sets = [MASK_MAP[f"?{m}"] for m in mask.split("?")[1:] if f"?{m}" in MASK_MAP]
    return len(list(itertools.product(*char_sets)))